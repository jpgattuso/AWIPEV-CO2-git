discrete$phcalc<- carb$pH
discrete$pco2calc<- carb$pCO2
# xx <- read_tsv("../fb_server/ny-alesund/data/old/All_sensors_731101_2016-08-20.txt", skip=16, col_names=TRUE)
load(file = paste0(path, "fb_awipev-co2_server/ny-alesund/data/processed/nydata_hour.Rdata"))
#load(file = paste0(path, "fb_server/shinyroot/AWIPEV-CO2/nydata_hour_shiny.Rdata"))
#load(file = "../fb_server/shinyroot/AWIPEV-CO2/nydata_shiny.Rdata") #d
# load = d_hour
d_hour <- d_hour %>%
dplyr::select(-date) %>%
dplyr::mutate(AT = ifelse(datetime > "2016-02-26 12:00:00", AT, NA), # beginning of data series for AT
AT = ifelse(AT == "NaN", NA, AT), #3 columns are character
pH_AT = ifelse(pH_AT == "NaN", NA, pH_AT),
PCO2_Corr_Zero2 = ifelse(PCO2_Corr_Zero2 %in% c("NaN", 66666), NA, PCO2_Corr_Zero2)
) %>%
dplyr::rename(at_contros=AT, ph_at_contros=pH_AT, pco2_contros=PCO2_corr_contros_filtered, zero_contros=PCO2_Corr_Zero2,
sal_fb=Salinity_filtered, temp_fb=Temperature_filtered, pH_durafet=HW_pH1_filtered, temp_insitu=Temp_SBE38_filtered)
View(d_hour)
d_all <- d_hour #d_all will be the merger
d_all<- d_all%>%
dplyr::mutate(month = month(month(datetime)))
# at
closest <- which.closest(discrete$datetime, d_all$datetime) # closest date and time
discrete$closest_datetime <- d_all$datetime[closest]
# if the closest value is more than 30 min away, then we do not take it
discrete$closest_datetime[abs(discrete$datetime - d_all$datetime[closest]) > 30*60] <- NA
# remove the drop_na() because of seafet/durafet line with na
discrete2merge <- discrete %>%
#drop_na() %>%
dplyr::select(closest_datetime, at, qflag_at) %>%
rename(datetime=closest_datetime)
d_all <- full_join(d_all, discrete2merge, by="datetime")
# ct
# closest <- which.closest(discrete$datetime, d$datetime) # closest date and time
# discrete$closest_datetime <- d$datetime[closest]
# # if the closest value is more than 30 min away, then we do not take it
# discrete$closest_datetime[abs(discrete$datetime - d$datetime[closest]) > 30*60] <- NA
discrete2merge <- discrete %>%
#drop_na() %>%
dplyr::select(closest_datetime, ct, qflag_ct) %>%
rename(datetime=closest_datetime)
View(d_all)
#
Sys.setlocale("LC_ALL", "en_US.UTF-8")
Sys.setenv(TZ='UTC') # on utilise UTC
rm(list = ls())
library(tidyverse)
library(robfilter)
library(seacarb)
library(gridExtra)
library(reshape2)
library(lubridate)
library(lmtest)
library(grid)
library(viridis)
library(dygraphs)
require("knitr")
library("lmodel2")
library(captioner)
library(xts)
library(seismicRoll)
library(scales)
knitr::opts_chunk$set(echo = TRUE)
fig_nums <- captioner()
table_nums <- captioner(prefix = "Table")
#define who is the user and define path
if (Sys.getenv("LOGNAME") == "gattuso") path = "../../pCloud\ Sync/Documents/experiments/exp168_awipev-CO2/"
if (Sys.getenv("LOGNAME") == "samir") path = "../../pCloud\ Sync/exp168_awipev-CO2/"
######## function to make regression plot with model I equation in title
ggreg <- function (fit, point_size=2) {
ggplot(fit$model, aes_string(x = names(fit$model)[2],
y = names(fit$model)[1])) +
geom_point(size = point_size, col = "blue") +
stat_smooth(method = "lm", col = "black") +
labs(title = paste(title, "\nAdj R2 = ",signif(summary(fit)$adj.r.squared, 5),
"; Intercept =",signif(fit$coef[[1]],5 ),
"; Slope =",signif(fit$coef[[2]], 5),
"; P =",signif(summary(fit)$coef[2,4], 5))) +
theme(plot.title = element_text(size=7))
}
#################### which.closest function
which.closest <- function(x, table, ...) {
round(approx(x=table, y=1:length(table), xout=x, ...)$y)
}
#################### Regression function
# function regression plot with model II equation (MA) in title
## Dans labs ajout de la variable TITRE pour mettre titre avant chaque graphe
ggreg2 <- function (fit, xdata, ydata) { # x and y are the names of the variables
fit_data <- data.frame(fit$x, fit$y)
colnames(fit_data) = c(xdata, ydata)
reg <- fit$regression.results[2,] #one selects MA only
intercept <- reg$Intercept
slope <- reg$Slope
ggplot(data = fit_data, aes_string(x = xdata, y = ydata)) +
geom_point(size = 3, col = "blue") +
geom_abline(aes(intercept = fit$regression.results[2,2], slope = fit$regression.results[2,3]),
colour = "blue")  +
labs(title = paste(titre,"\n Adj R2 = ", signif(fit$rsquare, 3),
"; Intercept =", signif(intercept, 3),
"; Slope =", signif(slope, 3),
"; P =", signif(fit$P.param, 3)))
}
mytheme <- theme_bw() +
theme(axis.text.x=element_text(size=16, color="black"),
axis.title.x=element_text(face="bold", size=16),
axis.text.y=element_text(size=16, color="black"),
axis.title.y=element_text(face="bold", size=16),
plot.title = element_text(face="bold", size=14)
)
#################### Mytheme
Mytheme <- function(size_labs = 7, face_font="plain") {
theme_bw() +
theme(axis.text.x = element_text(face=face_font, size=size_labs, color="black"),
axis.title.x = element_text(face=face_font, size=size_labs),
axis.text.y = element_text(face=face_font, color="black", size=size_labs),
axis.title.y = element_text(face=face_font, size=size_labs),
axis.ticks.x = element_line(size=0.1),
axis.ticks.y = element_line(size=0.1),
axis.ticks.length = unit(1.1, "mm"),
panel.grid.major = element_line(size = 0.25, color="black", linetype="dashed"),
aspect.ratio = 1 / 2,
plot.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "cm")
)
}
ggplotRegression <- function(fit){
require(ggplot2)
ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) +
geom_point() +
stat_smooth(method = "lm", col = "red", se= FALSE) +
labs(title = paste("Adj R2 = ",signif(summary(fit)$adj.r.squared, 5),
"Intercept =",signif(fit$coef[[1]],5 ),
" Slope =",signif(fit$coef[[2]], 5),
" P =",signif(summary(fit)$coef[2,4], 5)))
}
d <- read.table(paste0(path, "fb_data/Discrete_analyses_AT_CT/Discrete_sampling_AWIPEV.csv"), header = T, dec = ".", as.is = T, sep = ";", fill = TRUE)
d$datetime <- as.POSIXct(d$sampling_date, format="%d/%m/%Y %H:%M", tz="UTC")
d$measure_date <- dmy(d$measure_date, tz="UTC")
# Add the flag location: some samples have been collected at the peer. Notes them here.
# Flag 1 = collected on the peer by Niskin and flag 0 = collected in the FB (normal collect)
# And keep data with flag 0 for FB location
d <- d%>%
dplyr::mutate(location_flag = ifelse(datetime == "2016-04-21 09:25:00" | datetime == "2016-02-10 14:00:00" | datetime == "2016-02-17 09:20:00" |datetime == "2016-02-24 14:20:00" | datetime == "2016-02-04 09:30:00" |datetime == "2016-01-27 15:00:00" |datetime == "2016-01-13 13:45:00" |datetime == "2016-01-06 14:10:00" |datetime == "2015-12-24 10:45:00" |datetime == "2015-12-30 13:30:00" |datetime == "2018-01-05 15:20:00" |datetime == "2018-02-02 14:35:00"|datetime == "2018-03-02 14:10:00", 1,0)
)
d <- d%>%
dplyr::filter(location_flag== 0)
# Keep only flag = 2 for at/ct analysis
# Keep only flag = 2 for pH durafet and seaFET.
d <- d%>%
dplyr::mutate(ct= replace(ct, qflag_ct != 2, NA),
at= replace(at, qflag_at != 2, NA),
pH_s_seafet= replace(pH_s_seafet, qflag_pH_s_seafet != 2, NA),
pH_s_durafet= replace(pH_s_durafet, qflag_pH_s_durafet != 2, NA))
# Mercury chloride correction (Dickson et al. 2007, SOP3a)
# AT
d$at <- d$at * 1.0002
#CT
d$ct <- d$ct * 1.0002
# Fill "at/ct" to all line with same day.
at_ct_mean <- d %>%
group_by(datetime)%>%
dplyr::summarize(at_mean = mean(at, na.rm = T),
ct_mean = mean(ct, na.rm = T),
at_sd = sd(at, na.rm = T),
ct_sd = sd(ct, na.rm = T)
)
d <- left_join(d, at_ct_mean, by='datetime')
# Fill the gaps in at_mean with interpolation
TAinterp <-approx(d$datetime, d$at_mean, xout=d$datetime, method="linear", rule=2)
names(TAinterp) <- c("datetime", "at_mean_interp")
TAinterp <- as.data.frame(TAinterp)
d$at_mean_interp <- TAinterp$at_mean_interp
CTinterp <-approx(d$datetime, d$ct_mean, xout=d$datetime, method="linear", rule=2)
names(CTinterp) <- c("datetime", "ct_mean_interp")
CTinterp <- as.data.frame(CTinterp)
d$ct_mean_interp <- CTinterp$ct_mean_interp
# Conversion of spectro pH to a same T°
pH_seafet <- d %>%
dplyr::filter(!is.na(pH_s_seafet))
pH_seafet <- pH_seafet %>%
dplyr::mutate(pH_s_seafet_temp_field = pHinsi(pH=pH_seafet$pH_s_seafet,ALK=pH_seafet$at_mean_interp*1e-6, Tinsi=pH_seafet$temp_field, Tlab=pH_seafet$temp_s_lab, Pinsi= pH_seafet$depth/10, S=pH_seafet$salinity_field,Pt=0,Sit=0))
pH_durafet <- d %>%
dplyr::filter(!is.na(pH_s_durafet))
pH_durafet <- pH_durafet %>%
dplyr::mutate(pH_s_durafet_temp_field = pHinsi(pH=pH_durafet$pH_s_durafet,ALK=pH_durafet$at_mean_interp*1e-6, Tinsi=pH_durafet$temp_field, Tlab=pH_durafet$temp_s_lab, Pinsi= pH_durafet$depth/10, S=pH_durafet$salinity_field,Pt=0,Sit=0))
# create separate seafet/durafet df to join to initial "d" df
pH_seafet_mean <- pH_seafet%>%
dplyr::select(datetime,pH_s_seafet_temp_field)%>%
dplyr::group_by(datetime) %>%
dplyr::summarize(pH_s_seafet_temp_field = mean(pH_s_seafet_temp_field, na.rm = T))
pH_durafet_mean <- pH_durafet%>%
dplyr::select(datetime,pH_s_durafet_temp_field)%>%
dplyr::group_by(datetime) %>%
dplyr::summarize(pH_s_durafet_temp_field = mean(pH_s_durafet_temp_field, na.rm = T))
#  make means in "d" to have same format and call it "discrete"
discrete <- d %>%
dplyr::group_by(datetime) %>%
dplyr::summarize(sal = mean(salinity_field, na.rm = T),
temp = mean(temp_field, na.rm = T),
at_mean_interp = mean(at_mean_interp, na.rm = T),
at = mean(at, na.rm = T),
qflag_at = mean(qflag_at, na.rm = T),
ct_mean_interp = mean(ct_mean_interp, na.rm = T),
ct = mean(ct, na.rm = T),
qflag_ct = mean(qflag_ct, na.rm = T)
)
# join discrete + seafet/durafet
discrete <- left_join(discrete, pH_seafet_mean, by='datetime')
discrete <- left_join(discrete, pH_durafet_mean, by='datetime')
##   *****Attention, temp noted by logisticians in d is FB temp with SBE45 ******
# discrete_steffen <- discrete[c(21:72),1:4]
# write.table( discrete_steffen,"../fb_data/DiscreteTA_for_steffen.txt", sep= ",", dec=".", row.names = FALSE)
carb <- carb(15, discrete$at*1e-6, discrete$ct*1e-6,S=discrete$sal, T=discrete$temp, P=0, Pt=0, Sit=0,k1k2="l", kf="dg", ks="d", pHscale="T", b="u74")
discrete$phcalc<- carb$pH
discrete$pco2calc<- carb$pCO2
# xx <- read_tsv("../fb_server/ny-alesund/data/old/All_sensors_731101_2016-08-20.txt", skip=16, col_names=TRUE)
load(file = paste0(path, "fb_awipev-co2_server/ny-alesund/data/processed/nydata_hour.Rdata"))
#load(file = paste0(path, "fb_server/shinyroot/AWIPEV-CO2/nydata_hour_shiny.Rdata"))
#load(file = "../fb_server/shinyroot/AWIPEV-CO2/nydata_shiny.Rdata") #d
# load = d_hour
d_hour <- d_hour %>%
dplyr::select(-date) %>%
dplyr::mutate(AT = ifelse(datetime > "2016-02-26 12:00:00", AT, NA), # beginning of data series for AT
AT = ifelse(AT == "NaN", NA, AT), #3 columns are character
pH_AT = ifelse(pH_AT == "NaN", NA, pH_AT),
PCO2_Corr_Zero2 = ifelse(PCO2_Corr_Zero2 %in% c("NaN", 66666), NA, PCO2_Corr_Zero2)
) %>%
dplyr::rename(at_contros=AT, ph_at_contros=pH_AT, pco2_contros=PCO2_corr_contros_filtered, zero_contros=PCO2_Corr_Zero2,
sal_fb=Salinity_filtered, temp_fb=Temperature_filtered, pH_durafet=HW_pH1_filtered, temp_insitu=Temp_SBE38_filtered)
d_all <- d_hour #d_all will be the merger
d_all<- d_all%>%
dplyr::mutate(month = month(month(datetime)))
# at
closest <- which.closest(discrete$datetime, d_all$datetime) # closest date and time
discrete$closest_datetime <- d_all$datetime[closest]
# if the closest value is more than 30 min away, then we do not take it
discrete$closest_datetime[abs(discrete$datetime - d_all$datetime[closest]) > 30*60] <- NA
# remove the drop_na() because of seafet/durafet line with na
discrete2merge <- discrete %>%
#drop_na() %>%
dplyr::select(closest_datetime, at, qflag_at) %>%
rename(datetime=closest_datetime)
d_all <- full_join(d_all, discrete2merge, by="datetime")
# ct
# closest <- which.closest(discrete$datetime, d$datetime) # closest date and time
# discrete$closest_datetime <- d$datetime[closest]
# # if the closest value is more than 30 min away, then we do not take it
# discrete$closest_datetime[abs(discrete$datetime - d$datetime[closest]) > 30*60] <- NA
discrete2merge <- discrete %>%
#drop_na() %>%
dplyr::select(closest_datetime, ct, qflag_ct) %>%
rename(datetime=closest_datetime)
View(d_all)
d_all <- d_hour #d_all will be the merger
d_all<- d_all%>%
dplyr::mutate(month = month(month(datetime)))
View(d_all)
# at
closest <- which.closest(discrete$datetime, d_all$datetime) # closest date and time
discrete$closest_datetime <- d_all$datetime[closest]
# if the closest value is more than 30 min away, then we do not take it
discrete$closest_datetime[abs(discrete$datetime - d_all$datetime[closest]) > 30*60] <- NA
# remove the drop_na() because of seafet/durafet line with na
discrete2merge <- discrete %>%
#drop_na() %>%
dplyr::select(closest_datetime, at, qflag_at) %>%
rename(datetime=closest_datetime)
View(d_all)
View(discrete2merge)
# remove the drop_na() because of seafet/durafet line with na
discrete2merge <- discrete %>%
#drop_na() %>%
dplyr::select(closest_datetime, at, qflag_at) %>%
rename(datetime=closest_datetime)
View(discrete2merge)
View(discrete)
# at
closest <- which.closest(discrete$datetime, d_all$datetime) # closest date and time
closest
discrete$closest_datetime <- d_all$datetime[closest]
View(discrete)
View(discrete)
View(d_all)
View(d_hour)
View(discrete)
d_all <- d_hour #d_all will be the merger
d_all<- d_all%>%
dplyr::mutate(month = month(month(datetime)))
# at
closest <- which.closest(discrete$datetime, d_all$datetime) # closest date and time
discrete$closest_datetime <- d_all$datetime[closest]
# if the closest value is more than 30 min away, then we do not take it
discrete$closest_datetime[abs(discrete$datetime - d_all$datetime[closest]) > 30*60] <- NA
# remove the drop_na() because of seafet/durafet line with na
discrete2merge <- discrete %>%
#drop_na() %>%
dplyr::select(closest_datetime, at, qflag_at) %>%
rename(datetime=closest_datetime)
d_all <- full_join(d_all, discrete2merge, by="datetime")
# ct
# closest <- which.closest(discrete$datetime, d$datetime) # closest date and time
# discrete$closest_datetime <- d$datetime[closest]
# # if the closest value is more than 30 min away, then we do not take it
# discrete$closest_datetime[abs(discrete$datetime - d$datetime[closest]) > 30*60] <- NA
discrete2merge <- discrete %>%
#drop_na() %>%
dplyr::select(closest_datetime, ct, qflag_ct) %>%
rename(datetime=closest_datetime)
View(discrete2merge)
d_all <- d_hour #d_all will be the merger
d_all<- d_all%>%
dplyr::mutate(month = month(month(datetime)))
# at
#
Sys.setlocale("LC_ALL", "en_US.UTF-8")
Sys.setenv(TZ='UTC') # on utilise UTC
rm(list = ls())
library(tidyverse)
library(robfilter)
library(seacarb)
library(gridExtra)
library(reshape2)
library(lubridate)
library(lmtest)
library(grid)
library(viridis)
library(dygraphs)
require("knitr")
library("lmodel2")
library(captioner)
library(xts)
library(seismicRoll)
library(scales)
knitr::opts_chunk$set(echo = TRUE)
fig_nums <- captioner()
table_nums <- captioner(prefix = "Table")
#define who is the user and define path
if (Sys.getenv("LOGNAME") == "gattuso") path = "../../pCloud\ Sync/Documents/experiments/exp168_awipev-CO2/"
if (Sys.getenv("LOGNAME") == "samir") path = "../../pCloud\ Sync/exp168_awipev-CO2/"
######## function to make regression plot with model I equation in title
ggreg <- function (fit, point_size=2) {
ggplot(fit$model, aes_string(x = names(fit$model)[2],
y = names(fit$model)[1])) +
geom_point(size = point_size, col = "blue") +
stat_smooth(method = "lm", col = "black") +
labs(title = paste(title, "\nAdj R2 = ",signif(summary(fit)$adj.r.squared, 5),
"; Intercept =",signif(fit$coef[[1]],5 ),
"; Slope =",signif(fit$coef[[2]], 5),
"; P =",signif(summary(fit)$coef[2,4], 5))) +
theme(plot.title = element_text(size=7))
}
#################### which.closest function
which.closest <- function(x, table, ...) {
round(approx(x=table, y=1:length(table), xout=x, ...)$y)
}
#################### Regression function
# function regression plot with model II equation (MA) in title
## Dans labs ajout de la variable TITRE pour mettre titre avant chaque graphe
ggreg2 <- function (fit, xdata, ydata) { # x and y are the names of the variables
fit_data <- data.frame(fit$x, fit$y)
colnames(fit_data) = c(xdata, ydata)
reg <- fit$regression.results[2,] #one selects MA only
intercept <- reg$Intercept
slope <- reg$Slope
ggplot(data = fit_data, aes_string(x = xdata, y = ydata)) +
geom_point(size = 3, col = "blue") +
geom_abline(aes(intercept = fit$regression.results[2,2], slope = fit$regression.results[2,3]),
colour = "blue")  +
labs(title = paste(titre,"\n Adj R2 = ", signif(fit$rsquare, 3),
"; Intercept =", signif(intercept, 3),
"; Slope =", signif(slope, 3),
"; P =", signif(fit$P.param, 3)))
}
mytheme <- theme_bw() +
theme(axis.text.x=element_text(size=16, color="black"),
axis.title.x=element_text(face="bold", size=16),
axis.text.y=element_text(size=16, color="black"),
axis.title.y=element_text(face="bold", size=16),
plot.title = element_text(face="bold", size=14)
)
#################### Mytheme
Mytheme <- function(size_labs = 7, face_font="plain") {
theme_bw() +
theme(axis.text.x = element_text(face=face_font, size=size_labs, color="black"),
axis.title.x = element_text(face=face_font, size=size_labs),
axis.text.y = element_text(face=face_font, color="black", size=size_labs),
axis.title.y = element_text(face=face_font, size=size_labs),
axis.ticks.x = element_line(size=0.1),
axis.ticks.y = element_line(size=0.1),
axis.ticks.length = unit(1.1, "mm"),
panel.grid.major = element_line(size = 0.25, color="black", linetype="dashed"),
aspect.ratio = 1 / 2,
plot.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "cm")
)
}
ggplotRegression <- function(fit){
require(ggplot2)
ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) +
geom_point() +
stat_smooth(method = "lm", col = "red", se= FALSE) +
labs(title = paste("Adj R2 = ",signif(summary(fit)$adj.r.squared, 5),
"Intercept =",signif(fit$coef[[1]],5 ),
" Slope =",signif(fit$coef[[2]], 5),
" P =",signif(summary(fit)$coef[2,4], 5)))
}
d <- read.table(paste0(path, "fb_data/Discrete_analyses_AT_CT/Discrete_sampling_AWIPEV.csv"), header = T, dec = ".", as.is = T, sep = ";", fill = TRUE)
d$datetime <- as.POSIXct(d$sampling_date, format="%d/%m/%Y %H:%M", tz="UTC")
d$measure_date <- dmy(d$measure_date, tz="UTC")
# Add the flag location: some samples have been collected at the peer. Notes them here.
# Flag 1 = collected on the peer by Niskin and flag 0 = collected in the FB (normal collect)
# And keep data with flag 0 for FB location
d <- d%>%
dplyr::mutate(location_flag = ifelse(datetime == "2016-04-21 09:25:00" | datetime == "2016-02-10 14:00:00" | datetime == "2016-02-17 09:20:00" |datetime == "2016-02-24 14:20:00" | datetime == "2016-02-04 09:30:00" |datetime == "2016-01-27 15:00:00" |datetime == "2016-01-13 13:45:00" |datetime == "2016-01-06 14:10:00" |datetime == "2015-12-24 10:45:00" |datetime == "2015-12-30 13:30:00" |datetime == "2018-01-05 15:20:00" |datetime == "2018-02-02 14:35:00"|datetime == "2018-03-02 14:10:00", 1,0)
)
d <- d%>%
dplyr::filter(location_flag== 0)
# Keep only flag = 2 for at/ct analysis
# Keep only flag = 2 for pH durafet and seaFET.
d <- d%>%
dplyr::mutate(ct= replace(ct, qflag_ct != 2, NA),
at= replace(at, qflag_at != 2, NA),
pH_s_seafet= replace(pH_s_seafet, qflag_pH_s_seafet != 2, NA),
pH_s_durafet= replace(pH_s_durafet, qflag_pH_s_durafet != 2, NA))
# Mercury chloride correction (Dickson et al. 2007, SOP3a)
# AT
d$at <- d$at * 1.0002
#CT
d$ct <- d$ct * 1.0002
# Fill "at/ct" to all line with same day.
at_ct_mean <- d %>%
group_by(datetime)%>%
dplyr::summarize(at_mean = mean(at, na.rm = T),
ct_mean = mean(ct, na.rm = T),
at_sd = sd(at, na.rm = T),
ct_sd = sd(ct, na.rm = T)
)
d <- left_join(d, at_ct_mean, by='datetime')
# Fill the gaps in at_mean with interpolation
TAinterp <-approx(d$datetime, d$at_mean, xout=d$datetime, method="linear", rule=2)
names(TAinterp) <- c("datetime", "at_mean_interp")
TAinterp <- as.data.frame(TAinterp)
d$at_mean_interp <- TAinterp$at_mean_interp
CTinterp <-approx(d$datetime, d$ct_mean, xout=d$datetime, method="linear", rule=2)
names(CTinterp) <- c("datetime", "ct_mean_interp")
CTinterp <- as.data.frame(CTinterp)
d$ct_mean_interp <- CTinterp$ct_mean_interp
# Conversion of spectro pH to a same T°
pH_seafet <- d %>%
dplyr::filter(!is.na(pH_s_seafet))
pH_seafet <- pH_seafet %>%
dplyr::mutate(pH_s_seafet_temp_field = pHinsi(pH=pH_seafet$pH_s_seafet,ALK=pH_seafet$at_mean_interp*1e-6, Tinsi=pH_seafet$temp_field, Tlab=pH_seafet$temp_s_lab, Pinsi= pH_seafet$depth/10, S=pH_seafet$salinity_field,Pt=0,Sit=0))
pH_durafet <- d %>%
dplyr::filter(!is.na(pH_s_durafet))
pH_durafet <- pH_durafet %>%
dplyr::mutate(pH_s_durafet_temp_field = pHinsi(pH=pH_durafet$pH_s_durafet,ALK=pH_durafet$at_mean_interp*1e-6, Tinsi=pH_durafet$temp_field, Tlab=pH_durafet$temp_s_lab, Pinsi= pH_durafet$depth/10, S=pH_durafet$salinity_field,Pt=0,Sit=0))
# create separate seafet/durafet df to join to initial "d" df
pH_seafet_mean <- pH_seafet%>%
dplyr::select(datetime,pH_s_seafet_temp_field)%>%
dplyr::group_by(datetime) %>%
dplyr::summarize(pH_s_seafet_temp_field = mean(pH_s_seafet_temp_field, na.rm = T))
pH_durafet_mean <- pH_durafet%>%
dplyr::select(datetime,pH_s_durafet_temp_field)%>%
dplyr::group_by(datetime) %>%
dplyr::summarize(pH_s_durafet_temp_field = mean(pH_s_durafet_temp_field, na.rm = T))
#  make means in "d" to have same format and call it "discrete"
discrete <- d %>%
dplyr::group_by(datetime) %>%
dplyr::summarize(sal = mean(salinity_field, na.rm = T),
temp = mean(temp_field, na.rm = T),
at_mean_interp = mean(at_mean_interp, na.rm = T),
at = mean(at, na.rm = T),
qflag_at = mean(qflag_at, na.rm = T),
ct_mean_interp = mean(ct_mean_interp, na.rm = T),
ct = mean(ct, na.rm = T),
qflag_ct = mean(qflag_ct, na.rm = T)
)
# join discrete + seafet/durafet
discrete <- left_join(discrete, pH_seafet_mean, by='datetime')
discrete <- left_join(discrete, pH_durafet_mean, by='datetime')
##   *****Attention, temp noted by logisticians in d is FB temp with SBE45 ******
# discrete_steffen <- discrete[c(21:72),1:4]
# write.table( discrete_steffen,"../fb_data/DiscreteTA_for_steffen.txt", sep= ",", dec=".", row.names = FALSE)
carb <- carb(15, discrete$at*1e-6, discrete$ct*1e-6,S=discrete$sal, T=discrete$temp, P=0, Pt=0, Sit=0,k1k2="l", kf="dg", ks="d", pHscale="T", b="u74")
discrete$phcalc<- carb$pH
discrete$pco2calc<- carb$pCO2
# xx <- read_tsv("../fb_server/ny-alesund/data/old/All_sensors_731101_2016-08-20.txt", skip=16, col_names=TRUE)
load(file = paste0(path, "fb_awipev-co2_server/ny-alesund/data/processed/nydata_hour.Rdata"))
#load(file = paste0(path, "fb_server/shinyroot/AWIPEV-CO2/nydata_hour_shiny.Rdata"))
#load(file = "../fb_server/shinyroot/AWIPEV-CO2/nydata_shiny.Rdata") #d
# load = d_hour
d_hour <- d_hour %>%
dplyr::select(-date) %>%
dplyr::mutate(AT = ifelse(datetime > "2016-02-26 12:00:00", AT, NA), # beginning of data series for AT
AT = ifelse(AT == "NaN", NA, AT), #3 columns are character
pH_AT = ifelse(pH_AT == "NaN", NA, pH_AT),
PCO2_Corr_Zero2 = ifelse(PCO2_Corr_Zero2 %in% c("NaN", 66666), NA, PCO2_Corr_Zero2)
) %>%
dplyr::rename(at_contros=AT, ph_at_contros=pH_AT, pco2_contros=PCO2_corr_contros_filtered, zero_contros=PCO2_Corr_Zero2,
sal_fb=Salinity_filtered, temp_fb=Temperature_filtered, pH_durafet=HW_pH1_filtered, temp_insitu=Temp_SBE38_filtered)
d_all <- d_hour #d_all will be the merger
d_all<- d_all%>%
dplyr::mutate(month = month(month(datetime)))
# at
closest <- which.closest(discrete$datetime, d_all$datetime) # closest date and time
discrete$closest_datetime <- d_all$datetime[closest]
# if the closest value is more than 30 min away, then we do not take it
discrete$closest_datetime[abs(discrete$datetime - d_all$datetime[closest]) > 30*60] <- NA
# remove the drop_na() because of seafet/durafet line with na
discrete2merge <- discrete %>%
#drop_na() %>%
dplyr::select(closest_datetime, at, qflag_at) %>%
rename(datetime=closest_datetime)
View(discrete2merge)
d_all <- full_join(d_all, discrete2merge, by="datetime")
